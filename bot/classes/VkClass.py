import asyncio
import traceback
from typing import Optional

from vkbottle import Keyboard, Text, VKAPIError, KeyboardButtonColor, Callback
from vkbottle.bot import Bot
import re

from bot.classes.CommandClass import Commands
from settings import product_server, platform_tokens
from re import findall
from bot.utils.types import Message
from loguru import logger

from bot.utils.images import Images


class VkClass(Commands):
    platform = 'vk'
    base = ('base_of_bot', 'base_of_bot')  # –ù–∞–∑–≤–∞–Ω–∏–µ –ë–î. –í—Ç–æ—Ä–∞—è –±–∞–∑–∞ - –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –±–æ—Ç–∞

    bot_id = (1124824021, 1137923067)  # –ü–µ—Ä–≤—ã–π - –æ—Å–Ω–æ–≤–Ω–æ–π –±–æ—Ç, –≤—Ç–æ—Ä–æ–π - —Ç–µ—Å—Ç–æ–≤—ã–π
    vk_color = {  # –¶–≤–µ—Ç–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä –≤–∫
        'blue': KeyboardButtonColor.PRIMARY,  # –°–∏–Ω—è—è
        'white': KeyboardButtonColor.SECONDARY,  # –ë–µ–ª–∞—è
        'red': KeyboardButtonColor.NEGATIVE,  # –ö—Ä–∞—Å–Ω–∞—è
        'green': KeyboardButtonColor.POSITIVE,  # –ó–µ–ª—ë–Ω–∞—è
    }
    admins = (569930838,)  # ID –∞–¥–º–∏–Ω–æ–≤
    image = Images(platform)

    def distribute_platform_commands(self, ):
        specific_bot_commands = {  # –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –¥–ª—è –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –∫–æ–º–∞–Ω–¥—ã
            'message_commands': (),
            'message_commands_with_params': (),
            'message_commands_with_reply': (),
            'message_commands_with_attachment': (),
            'callback_messages': (),
            'callback_messages_with_params': (),
        }
        for command_type in self.bot_commands.keys():
            self.bot_commands[command_type] = self.bot_commands[command_type] + specific_bot_commands[command_type]

    def __init__(self):
        self.distribute_commands()
        self.distribute_platform_commands()
        logger.remove()
        product_index = 0 if product_server else 1
        self.base = self.base[product_index]
        self.group_id = self.bot_id[product_index]
        self.bot = Bot(platform_tokens['vk'])
        self.bot.labeler.message_view.replace_mention = True

        super().__init__()  # –í—ã–∑–æ–≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞ –∫–ª–∞—Å—Å–∞ —Ä–æ–¥–∏—Ç–µ–ª—è

        # –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥, —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –¥–ª—è –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –∫–æ–º–∞–Ω–¥—ã

    def start_receiving_updates(self):  # –°—Ç–∞—Ä—Ç –ø–æ–ª—É—á–µ–Ω–∏—è –∞–ø–¥–µ–π—Ç–æ–≤
        self.bot.loop_wrapper.add_task(self.on_startup())
        self.bot.run_forever()

    async def generate_keyboard(self, buttons):  # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
        if buttons is None or len(buttons) == 0:
            return None
        keyboard = Keyboard(inline=True)  # –ò–Ω–∏—Ü–∏–∏—Ä—É–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
        for button in buttons:  # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ –∫–Ω–æ–ø–∫–∏
            # –î–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–µ–≤–æ–¥ –Ω–∞ –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É
            if button['text'] in ('line', 'vk_line'):
                keyboard.row()
            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–µ–≤–æ–¥—ã —Å—Ç—Ä–æ–∫, –∫–æ—Ç–æ—Ä—ã–µ –¥–ª—è –¥—Ä—É–≥–∏—Ö —Å–æ—Ü. —Å–µ—Ç–µ–π
            elif button['text'] == 'tg_line':
                continue
            else:
                if 'type' in button and button['type'] in ('callback', 'vk_callback'):
                    keyboard.add(Callback(label=button['visible_text'], payload={'cmd': button['text']}))
                else:
                    if 'type' in button and button['type'] == 'tg_callback':
                        keyboard.add(Text(label=button['visible_text']), color=self.vk_color[button['color']])
                    else:
                        keyboard.add(Text(label=button['text']), color=self.vk_color[button['color']])

        keyboard = keyboard.get_json()  # –ì–µ—Ä–µ–Ω–∏—Ä—É–µ–º –æ–±—ä–µ–∫—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
        return keyboard

    async def get_message_id(self, message):  # –ü–æ–ª—É—á–µ–Ω–∏–µ ID –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
        if message and len(message) > 0 and hasattr(message[0], 'conversation_message_id'):
            return message[0].conversation_message_id
        else:
            return None

    # –§–æ—Ä–≤–∞—Ä–¥–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    async def forward_message(self, to_chat, from_chat, message_id, need_exception=False):
        pass

    async def send_message(self, message: Message, send_long_message=True):
        try:

            dont_parse_links = True if message.dont_parse_links == 1 else False
            message.ping = not message.ping

            msg = await self.bot.api.messages.send(
                chat_ids=[message.chat_id], message=message.message, attachment=message.attachment,
                disable_mentions=message.ping,
                keyboard=message.keyboard, random_id=0, dont_parse_links=dont_parse_links)
            if msg[0].error:
                return await self.write_msg_errors(msg[0].error.code, message.chat_id)
            if message.need_delete and message.chat_id in self.subscribed_chats:  # TODO –≤—ã–Ω–µ—Å—Ç–∏ –≤ –æ–±—â–∏–π –º–µ—Ç–æ–¥
                message_id = await self.get_message_id(msg)
                await self.message_for_delete(message_id=message_id, chat_id=message.chat_id)
            return msg
        except VKAPIError[914]:
            if send_long_message:
                pass
        except (VKAPIError[6], VKAPIError[9]) as e:
            async def recursive_call(exception):
                if hasattr(exception, 'timeout'):
                    timeout = exception.timeout
                else:
                    timeout = 1
                await asyncio.sleep(timeout)
                await self.send_message(message)  # Recursive call

            asyncio.create_task(recursive_call(e))
        except Exception as err:
            if not product_server:
                print(traceback.format_exc())
            if message.need_log:
                await self.write_log('send_message_log',
                                     f"{message.__dict__}\n" + traceback.format_exc())
            if message.need_exception:
                return await self.write_msg_errors(err, message.chat_id)

    # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    async def delete_message(self, message: Message):
        try:
            await self.bot.api.messages.delete(
                conversation_message_ids=message.message_id, peer_id=message.chat_id, delete_for_all=True)
        except:
            if not product_server:
                print(message.chat_id, message.message_id, traceback.format_exc())
            pass

    async def edit_message(self, message: Message):
        try:
            await self.bot.api.messages.edit(peer_id=message.chat_id, message=message.message,
                                             conversation_message_id=message.message_id,
                                             attachment=message.attachment, keyboard=message.keyboard)
        except (VKAPIError[6], VKAPIError[9]) as e:
            async def recursive_call(exception):
                if hasattr(exception, 'timeout'):
                    timeout = exception.timeout
                else:
                    timeout = 1
                await asyncio.sleep(timeout)
                await self.edit_message(message)  # Recursive call

            asyncio.create_task(recursive_call(e))
        except VKAPIError[914]:
            return "TooLongMessage"
        except Exception:
            await self.write_log('send_message_log',
                                 f"{message.chat_id}\n{message.message}\n{message.attachment}\n"
                                 + traceback.format_exc())

    # –ü–æ–ª—É—á–µ–Ω–∏–µ —é–∑–µ—Ä–∞ —á–µ–ª–æ–≤–µ–∫–∞, —Å –∫–æ—Ç–æ—Ä—ã–º –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å
    async def get_destination(self, param, reply_from):
        if reply_from is not None:
            return reply_from
        elif param is None:
            return None
        else:
            param = findall(r"\[id(\d*)\|", param)
            if param and await self.is_int(param[0]):
                destination = int(param[0])
                if destination > 0 or destination == -190195384:
                    return destination
                else:
                    return None
            else:
                return None

    async def is_admin(self, user, chat_id):  # –Ø–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–¥–º–∏–Ω–æ–º
        try:
            members = await self.bot.api.messages.get_conversation_members(
                peer_id=chat_id, fields=['is_admin']
            )
            for i in members.items:
                if i.member_id == user:
                    if i.is_admin:
                        return True
                    else:
                        return False
        except:
            await self.send_message(
                Message(chat_id, 'ü§ï' + '–î–ª—è –Ω–æ—Ä–º–∞–ª—å–Ω–æ–π —Ä–∞–±–æ—Ç—ã, –Ω—É–∂–Ω–æ –≤—ã–¥–∞—Ç—å –º–Ω–µ –∞–¥–º–∏–Ω-–ø—Ä–∞–≤–∞' + 'ü§ï',
                        attachment='photo-191097210_457242713')
            )
            return True

    # –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–õ—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å get_username)
    async def takename(self, user_id, chat_id):
        try:
            if user_id > 0:
                user_info, = await self.bot.api.users.get(user_id=user_id, random_id=0)
                name = user_info.first_name + " " + user_info.last_name
                return name
            else:
                return '—Å–≥–ª—ã–ø–∞)'
        except (VKAPIError[6], VKAPIError[9]) as e:
            async def recursive_call(exception):
                if hasattr(exception, 'timeout'):
                    timeout = exception.timeout
                else:
                    timeout = 1
                await asyncio.sleep(timeout)
                await self.takename(user_id, chat_id)  # Recursive call

            asyncio.create_task(recursive_call(e))

    # –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é —É–ø–æ–º—è–Ω—É—Ç—å –µ–≥–æ
    async def get_username(self, user_id: int, chat_id: int,
                           ping: bool = False,
                           special_name: Optional[str] = None) -> str:
        # –ï—Å–ª–∏ –Ω–µ –Ω—É–∂–Ω–æ —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ, –Ω–æ –∑–∞–¥–∞—ë—Ç—Å—è –∏–º—è, —Ç–æ –Ω–∞–¥–æ –ø—Ä–æ—Å—Ç–æ –≤–µ—Ä–Ω—É—Ç—å –∏–º—è
        if not ping and special_name is not None:
            return special_name
        user_info, = await self.bot.api.users.get(user_id=user_id, random_id=0)
        user_name = user_info.first_name + " " + user_info.last_name
        if ping:  # –ï—Å–ª–∏ –Ω—É–∂–Ω–æ —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ
            if special_name is None:
                user_name = special_name
            return f'[id{user_id}|{user_name}]'
        else:
            return user_name

    async def send_sticker(self, chat_id, sticker):
        await self.bot.api.messages.send(chat_id=chat_id, sticker_id=sticker, random_id=0)

    async def get_attachment_id(self, event, need_all=False):  # –ü–æ–ª—É—á–∞–µ–º id –≤–ª–æ–∂–µ–Ω–∏—è
        pass

    async def escape_string(self, s) -> Optional[str]:  # –≠–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏
        return re.sub(f'\\[.+?\\|.+?]', '', s)

    async def make_link(self, title, link):  # –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Å—ã–ª–∫—É
        # TODO –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, –º–æ–∂–µ—Ç –µ—Å—Ç—å –º–µ—Ç–æ–¥—ã –ª–∏–±—ã
        try:
            link = int(link)
            link = f'id{link}'
        except:
            pass
        return f'[{link}|{title}]'

    @staticmethod
    async def link_to_user(user_id):  # –ü–æ–ª—É—á–∞–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        return str(user_id)

    @staticmethod
    async def bold(s):  # –î–µ–ª–∞–µ–º —Ç–µ–∫—Å—Ç –∂–∏—Ä–Ω—ã–º
        return s

    @staticmethod
    async def italic(s):  # –î–µ–ª–∞–µ–º —Ç–µ–∫—Å—Ç –∫—É—Ä—Å–∏–≤–æ–º
        return s

    @staticmethod
    async def underline(s):  # –î–µ–ª–∞–µ–º —Ç–µ–∫—Å—Ç –ø–æ–¥—á–µ—Ä–∫–Ω—É—Ç—ã–º
        return s

    @staticmethod
    async def code(s):  # –î–µ–ª–∞–µ–º —Ç–µ–∫—Å—Ç monospace
        return s

    async def callback_message(self, message: Message, alert=True):
        event_data = {
            "type": "show_snackbar",
            "text": message.message
        }
        await self.bot.api.messages.send_message_event_answer(message.callback_id, user_id=message.user_id,
                                                              peer_id=message.chat_id, event_data=str(event_data))

    async def is_chat(self, chat_id):
        if chat_id > 2000000000:
            return True
        return False
